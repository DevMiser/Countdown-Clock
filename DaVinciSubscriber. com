import datetime
import paho.mqtt.client as mqtt
import io
import os
import schedule
import subprocess
import threading
import time
import tkinter as tk
import urllib.request
#from inky.auto import auto
from PIL import Image,ImageDraw,ImageFont,ImageOps,ImageEnhance,ImageTk
from threading import Thread,Event
from time import sleep

#XYdisplay = auto()

import RPi.GPIO as GPIO
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
led1_pin=4
GPIO.setup(led1_pin, GPIO.OUT)
GPIO.output(led1_pin, GPIO.LOW)

event=threading.Event()
event2=threading.Event()

# Create a global Tkinter window
root = tk.Tk()
root.title("Full Screen Image")
root.attributes("-fullscreen", True)
canvas = tk.Canvas(root, width=root.winfo_screenwidth(), height=root.winfo_screenheight())
#canvas = tk.Canvas(root, width=1280, height=800)
canvas.pack()
photo = None # Initialize a global photo variable

# Define a function to close or destroy the window
#def close_window(event):
def close_window(): 
    root.destroy()
    
def sleep_screen():
    # This function will put the screen to sleep using the xset command
    subprocess.run(["xset", "dpms", "force", "off"]) # This will run the command and wait for it to finish

def blank_screen():

    global photo # Use the global photo variable
#    raw_data = urllib.request.urlopen(image_url).read()
    img = Image.open("Blank.png")
    img = img.resize((1280, 800)) # Resize the image to 1280x800
    photo = ImageTk.PhotoImage(img)
#    photo_resized = photo.subsample(2, 2)# Update the photo variable
    canvas.create_image(-90, 0, image=photo, anchor=tk.NW) # Create a n
    root.bind("<Escape>", close_window)
    
def waiting_screen():
    global photo # Use the global photo variable
#    raw_data = urllib.request.urlopen(image_url).read()
    img = Image.open("Generating.png")
    img = img.resize((1280, 800)) # Resize the image to 1280x800
    photo = ImageTk.PhotoImage(img)
#    photo_resized = photo.subsample(2, 2)# Update the photo variable
    canvas.create_image(-70, 0, image=photo, anchor=tk.NW) # Create a n
    root.bind("<Escape>", close_window)
    os.system("xset dpms force on")   
    

# Bind the escape key and the q key to the close_window function
#root.bind("<Escape>", close_window)
#root.bind("q", close_window)

count = 0
"""
def clean_screen():
    cycles = 1
    colours = (display.RED, display.BLACK, display.WHITE, display.CLEAN)
    colour_names = (display.colour, "red", "black", "white", "clean")
    img = Image.new("P", (display.WIDTH, display.HEIGHT))
    for i in range(cycles):
        print("\nCleaning cycle %i of 2\n" % (i + 1))
        for j, c in enumerate(colours):
            print("- updating with %s" % colour_names[j+1])
            display.set_border(c)
            for x in range(display.WIDTH):
                for y in range(display.HEIGHT):
                    img.putpixel((x, y), c)
            display.set_image(img)
            display.show()
            time.sleep(1)
    print("\nCleaning complete")
"""    
def current_time():

    time_now = datetime.datetime.now()
    formatted_time = time_now.strftime("%m-%d-%Y %I:%M %p\n")
    print("The current date and time is:", formatted_time)
    
def fade_leds(event):

    pwm1 = GPIO.PWM(led1_pin, 200)

    event.clear()

    while not event.is_set():
        pwm1.start(0)
        for dc in range(0, 101, 5):
            pwm1.ChangeDutyCycle(dc)  
            time.sleep(0.05)
        time.sleep(0.75)
        for dc in range(100, -1, -5):
            pwm1.ChangeDutyCycle(dc)                
            time.sleep(0.05)
        time.sleep(0.75)

def on_connect(client, userdata, flags, rc):
#    print("\nConnected with result code "+str(rc)) #uncomment this line if you want to print the result code
    if rc == 0:
        print("\nConnection successful")
    else:
        print("Connection unsuccessful") 
    client.subscribe("AI-Art-Frame")

def update_image(image_url):
    global photo # Use the global photo variable
    raw_data = urllib.request.urlopen(image_url).read()
    img = Image.open(io.BytesIO(raw_data))
    img = img.resize((1400, 800)) # Resize the image to 1280x800
    photo = ImageTk.PhotoImage(img)
#    photo_resized = photo.subsample(2, 2)# Update the photo variable
    canvas.create_image(-100, 0, image=photo, anchor=tk.NW) # Create a n
    root.bind("<Escape>", close_window)
"""
def update_image(image_url):
    global photo # Use the global photo variable
    raw_data = urllib.request.urlopen(image_url).read()
    img = Image.open(io.BytesIO(raw_data))
    photo = tk.PhotoImage(data=raw_data)
#    photo_resized = photo.subsample(2, 2)# Update the photo variable
    canvas.create_image(0, 0, image=photo, anchor=tk.NW) # Create a new image item on the canvas
"""
def on_message(client, userdata, msg):
    print("\nMessage received from DaVinci\n")
    current_time()

    msg.payload = msg.payload.decode("utf-8") #decodes the UTF8 message to text
    if msg.payload == "Clean":
#         refresh_schedule.pause()
        print("Request to erase the screen received.")
        blank_screen()
        os.system("xset dpms force off") 
        root.update()
#        os.system("xset dpms force off") 
#        close_window()
#        pass

    elif msg.payload == "Waiting":
#         refresh_schedule.pause()
        print("Generating new image...")
        waiting_screen()
        root.update()
        
    elif msg.payload == "DisplayOn":
        os.system("xset dpms force on")
    
    elif msg.payload == "DisplayOff":
        os.system("xset dpms force off")

    else:

#        global img_resized
        image_url = str(msg.payload)
        t_fade = threading.Thread(target=fade_leds, args=(event,))
        t_fade.start()

        update_image(image_url) # Call the update_image function with the image url
        root.update() # Update the window

 
#        img_bordered = ImageOps.expand(img, border=(76,0), fill='black')    
#        img_resized = img_bordered.resize((600, 448), Image.ANTIALIAS)
#        display.set_image(img_resized)
#        display.set_border(display.BLACK)
        print("Rendering image...\n")
#        display.show()
#        img.show() #uncomment this line if you also want to show the image on a connected display
        event.set()
        GPIO.output(led1_pin, GPIO.LOW)
#        refresh_schedule.resume()
        print("Done")



"""
def refresh_screen():
    
    now = datetime.datetime.now()
    compare_time = now.strftime("%H:%M")
#    print(compare_time)
    if compare_time == "00:00":

        print("\nThe screen refreshes every day at midnight to help prevent burn-in\n")
        current_time()
        clean_screen()
        sleep(2)
        display.set_image(img_resized)
        display.set_border(display.BLACK)    
        print("\nRe-rendering")
        display.show()
        print("\nDone\n")
        
    else:
        pass

class RefreshSchedule:
    def __init__(self):
        self._paused = False
        self._lock = threading.Lock()
        self._cond = threading.Condition(self._lock)
        self._thread = threading.Thread(target=self.run)

    def run(self):
        schedule.every().day.at("00:00").do(refresh_screen) 
        while True:
            with self._lock:
                while self._paused:
                    self._cond.wait()
                schedule.run_pending()
            time.sleep(1)

    def pause(self):
        with self._lock:
            self._paused = True

    def resume(self):
        with self._lock:
            self._paused = False
            self._cond.notify()
"""
try:
    
    client = mqtt.Client()
    client.username_pw_set("DaVinci", "ImageExchange32")
    client.on_connect = on_connect
    client.on_message = on_message
    client.connect("192.168.1.221", 1883, 60)
    client.loop_forever()
    
except KeyboardInterrupt:
    print ("\nExiting ArtFrameDaVinciSubscriber")
    GPIO.cleanup



